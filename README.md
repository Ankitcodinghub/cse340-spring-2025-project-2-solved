# cse340-spring-2025-project-2-solved
**TO GET THIS SOLUTION VISIT:** [CSE340 SPRING 2025 Project 2 Solved](https://www.ankitcodinghub.com/product/cse340-spring-2025-project-2-solved/)


---

üì© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
üì± **WhatsApp:** +1 419 877 7882  
üìÑ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top kksr-disabled" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;133857&quot;,&quot;readonly&quot;:&quot;1&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;2&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (2 votes)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;CSE340 SPRING 2025 Project 2 Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (2 votes)    </div>
    </div>
<em>You</em> <em>may</em> <em>delay,</em> <em>but</em> <em>time</em> <em>will</em> <em>not.</em>‚Äì Benjamin Franklin

<em>If</em> <em>debugging</em> <em>is</em> <em>the</em> <em>process</em> <em>of</em> <em>removing</em> <em>software</em> <em>bugs,</em> <em>then</em> <em>programming</em> <em>must</em> <em>be</em> <em>the</em> <em>process</em> <em>of</em> <em>putting</em> <em>them</em> <em>in.</em>‚Äì Edsger Dijkstra

<em>If</em> <em>I</em> <em>had</em> <em>six</em> <em>hours</em> <em>to</em> <em>chop</em> <em>down</em> <em>a</em> <em>tree,</em> <em>I</em> <em>would</em> <em>spend</em> <em>the</em> <em>first</em> <em>four</em> <em>hours</em> <em>sharpening</em> <em>the</em> <em>axe.</em>‚Äì Abraham Lincoln <em>I</em> <em>had</em> <em>a</em> <em>running</em> <em>compiler</em> <em>and</em> <em>nobody</em> <em>would</em> <em>touch</em> <em>it.</em> <em>They</em> <em>told</em> <em>me</em> <em>computers</em> <em>could</em> <em>only</em> <em>do</em> <em>arithmetic.</em> ‚Äì Grace Murray Hopper (Inventor of the first compiler)

<h1>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; General Advice</h1>
You should read this specification document carefully. Multiple readings are recommended. Give yourself time by starting early and taking breaks between readings. You will digest the requirements better.

<ul>
<li>The answers to many of your questions can be found in this document.</li>
<li>Do not start coding until you have a complete understanding of the requirements. At the very least, do not start coding a task, until you have a complete understanding of the task‚Äôs requirement.</li>
<li>Ask for help early. I and the TAs can save you a lot of time if you ask for help early. You can get help with how to approach the project to make the solution easier and have an easier time implementing it. That said, when you ask for help, you should be prepared and you should have done your part. The lab and office hours schedule is posted on Canvas!</li>
<li>Have fun!</li>
</ul>
<h1>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Overview</h1>
In this project, you are asked to write a C++ program that reads a description of a context free grammar, then, depending on the command line argument passed to the program, performs one of the following tasks (see Section 6.3 for more details on how to run the program with command line arguments):

<ol>
<li>print the list of terminals followed by the list of non-terminals in the order in which they appear in the grammar,</li>
<li>calculate nullable non-terminals,</li>
<li>calculate FIRST sets,</li>
<li>calculate FOLLOW sets ,</li>
<li>left-factor the grammar,</li>
<li>eliminate left recursion.</li>
</ol>
All of these tasks are defined in detail in this specification document. We provide you with code to read the command line argument into an integer variable. Depending on the value of the variable, your program will invoke the appropriate functionality. The rest of the document is organized as follows:

<ol>
<li>Section 3 describes the input format (this is just syntax with no meaning).</li>
<li>Section 4 describes what the input represents (this is the semantics or meaning of the input).</li>
<li>Section 5 describes what the output of your program should be for each task. This is the largest section of the document.</li>
<li>Section 6 discusses command line arguments and how you should run and test your program.</li>
<li>Section 7 describes the grading scheme.</li>
<li>Section 8 addresses some potential submission concerns.</li>
</ol>
<table width="763">
<tbody>
<tr>
<td width="763"><strong>Important Note</strong>. For this project, there is a timeout that we enforce when testing submissions.

‚Ä¢&nbsp;&nbsp;&nbsp;&nbsp; Programs that are functionally correct but take an inordinate amount of time can be timed out before finishing execution.

‚Ä¢&nbsp;&nbsp;&nbsp;&nbsp; Write a recursive descent parser for the grammar, but <strong>DO NOT IMPLEMENT YOUR CALCULATIONS RECURSIVELY </strong>. If you try to invent a new recursive algorithm for calculating FIRST and FOLLOW sets, for example, it risks being timed out, and you will not get credit for test cases for which the program is timed out.

‚Ä¢&nbsp;&nbsp;&nbsp;&nbsp; If you follow the algorithms covered in class for <em>Nullable</em>, FIRST and FOLLOW and the algorithms that I cover here for left-factoring and elimination of left recursion, you should have no problem with timeout even if your implementation is not particularly efficient.
</td>
</tr>
</tbody>
</table>
<h1>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Input Format</h1>
The following context-free grammar specifies the input format:

<table width="763">
<tbody>
<tr>
<td width="201">Grammar</td>
<td width="28"><em>‚Üí</em></td>
<td width="534">Rule-list HASH</td>
</tr>
<tr>
<td width="201">Rule-list</td>
<td width="28"><em>‚Üí</em></td>
<td width="534">Rule Rule-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; Rule</td>
</tr>
<tr>
<td width="201">Id-list</td>
<td width="28"><em>‚Üí</em></td>
<td width="534">ID Id-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</td>
</tr>
<tr>
<td width="201">Rule</td>
<td width="28"><em>‚Üí</em></td>
<td width="534">ID ARROW Right-hand-side STAR</td>
</tr>
<tr>
<td width="201">Right-hand-side</td>
<td width="28"><em>‚Üí</em></td>
<td width="534">Id-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Id-list OR Right-hand-side</td>
</tr>
</tbody>
</table>
The input consists of a rule list. Each rule has a left-hand side which is an ID and a right-hand side which is one or more Id-list‚Äôs separated with OR‚Äôs and terminated with the STAR token. An Id-list is a list of zero or more ID‚ÄôsThe meaning of the input is explained in the <em>Semantics </em>section below.

The tokens used in the above grammar description are defined by the following regular expressions:

<table width="763">
<tbody>
<tr>
<td width="172">ID</td>
<td width="591">= letter (letter + digit)*</td>
</tr>
<tr>
<td width="172">STAR</td>
<td width="591">= ‚Äò*‚Äô</td>
</tr>
<tr>
<td width="172">HASH</td>
<td width="591">= #</td>
</tr>
<tr>
<td width="172">OR</td>
<td width="591">= |</td>
</tr>
<tr>
<td width="172">ARROW</td>
<td width="591">= -&gt;</td>
</tr>
</tbody>
</table>
digit is the set of digits from ‚Äò0‚Äô through ‚Äò9‚Äô and letter is the upper and lower case letters ‚Äòa‚Äô through ‚Äòz‚Äô and ‚ÄòA‚Äô through

‚ÄòZ‚Äô. Tokens are space separated and there is at least one whitespace character between any two successive tokens. We provide a lexer with a getToken() function to recognize these tokens. You should use the provided lexer in you solution. You should not modify the provided lexer.

<h1>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Semantics</h1>
The input represents a context-free grammar. The ID tokens represent the terminal and non-terminals of the grammar. The lexemes of these ID tokens are the <em>names </em>of the terminals and non-terminals of the grammar. Each grammar Rule starts with a non-terminal symbol (the left-hand side of the rule) followed by ARROW, followed by a right-hand side which is one or more Id-list‚Äôs separated with OR‚Äôs. and terminated with the STAR token. If an Id-list that appears on the right-hand of a rule is empty, then that Id-list represents .

The set of non-terminals for the grammar is the set of names that appear to the left of an arrow. Names that do not appear to the left of an arrow are terminal symbols. The start symbol of the grammar is the name of the left-hand side of the first rule of the grammar.

Note that the convention of using upper-case letters for non-terminals and lower-case letters for terminals that I typically followed in class does not apply in this project.

<h2>4.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Example</h2>
Here is an example input:

decl -&gt; idList colon ID * idList -&gt; ID idList1 *

idList1 -&gt; COMMA ID idList1 | *

#

The list of non-terminal symbols in the order in which they appear in the grammar is:

Non-Terminals = <em>{ </em>decl<em>, </em>idList<em>, </em>idList1 <em>}</em>

The list of terminal symbols in the order in which they appear in the grammar is:

Terminals = <em>{ </em>colon<em>, </em>ID<em>, </em>COMMA <em>}</em>

The grammar that this input represents is the following:

<table width="763">
<tbody>
<tr>
<td width="763">decl <em>‚Üí </em>idList colon ID

idList <em>‚Üí </em>ID idList1 idList1 <em>‚Üí </em>COMMA ID idList1 <em>| </em>
</td>
</tr>
</tbody>
</table>
Note that even though the example shows that each rule is on a line by itself, a rule can be split into multiple lines, or even multiple rules can be on the same line. Your should not confuse ID which is the name of a terminal of the input grammar in this example with ID which is a token The following input describes the same grammar as the above example:

decl -&gt; idList colon ID * idList -&gt; ID idList1 * idList1 -&gt;

COMMA ID idList1 | *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #

<h1>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Output Specifications: Tasks 1 ‚Äì 5</h1>
<strong>Parsing: </strong>There is no separate task for parsing the input. Your parser should properly parse the input and should output: SYNTAX ERROR !!!!!!!!!!!!!!

if the input has a syntax error, and it should not output: SYNTAX ERROR !!!!!!!!!!!!!!

if the input does not have a syntax error. There will be a deduction of 15% if your parser does not parse the input correctly.

Your program should read the input grammar from standard input (which is done by the provided lexer code), and read the requested task number from the first command line argument (as stated earlier, we provide code to read the task number). Then, your program should calculate the requested output based on the task number and should print the results in the specified format for given task to standard output (stdout). The following specifies the exact requirements for each task number.

<h2>5.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task 1: Printing Terminals and Non-terminals</h2>
Task 1 simply outputs the list of terminals <em>in the order in which they appear in the grammar rules </em>followed by the list of non-terminals <em>in the order in which they appear in the grammar rules</em>.

<strong>Example:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>For the input grammar

decl -&gt; idList colon ID * idList -&gt; ID idList1 *

idList1 -&gt; *

idList1 -&gt; COMMA ID idList1 * #

the expected output for task 1 is:

colon ID COMMA decl idList idList1

<strong>Example:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>Given the input grammar:

decl -&gt; idList colon ID *

idList1 -&gt; *

idList1 -&gt; COMMA ID idList1 * idList -&gt; ID idList1 * #

the expected output for task 1 is:

colon ID COMMA decl idList idList1

Note that in this example, even though the rule for idList1 is before the rule for idList, idList appears before idList1 in the grammar rules. To be clear, here is the grammar again with the order of each symbol added between parentheses after the first appearance of the symbol.

decl (1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; idList (2) colon (3) ID (4) * idList1 (5) -&gt; *

idList1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; COMMA (6) ID idList1 * idList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; ID idList1 *

#

<h2>5.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task 2: Calculate the set of nullable non-terminals</h2>
Calculate the set of nullable non-terminals, then output the set in the following format Nullable = { &lt;nullable_non_terminals&gt; }

where &lt;nullable_non_terminals&gt; should be replaced by a comma-separated list of nullable non-terminals. The list should be ordered according to the order in which non-terminals appear in the input grammar.

<strong>Example:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>Given the input grammar:

A-&gt; B F C D E F *

C -&gt; E F *

E -&gt; a E *

B -&gt; a E * E -&gt; a

F -&gt; *

D -&gt; *

C -&gt; D F *

#

the expected output for task 2 is:

Nullable = { F, C, D }

<h2>5.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task 3: Calculate FIRST Sets</h2>
Compute the FIRST sets for all the non-terminal symbols. Then, for each of the non-terminals of the input grammar, in the order in which it appears in the grammar, output one line in the following format: FIRST(&lt;symbol&gt;) = { &lt;set_elements&gt; }

where &lt;symbol&gt; should be replaced by the non-terminal name and &lt;set_elements&gt; should be replaced by a comma-separated list of elements of the set. The elements of the set should be ordered according to the order in which they appear in the grammar.

<strong>Example:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>Given the input grammar:

decl -&gt; idList colon ID * idList -&gt; ID idList1 *

idList1 -&gt; *

idList1 -&gt; COMMA ID idList1 *

#

the expected output for task 2 is:

FIRST(decl) = { ID }

FIRST(idList) = { ID }

FIRST(idList1) = { COMMA }

<h2>5.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task 4: Calculate FOLLOW Sets</h2>
Compute the FOLLOW sets for all the non-terminal symbols. Then, for each of the non-terminals of the input grammar, in the order in which it appears in the grammar, output one line in the following format:

FOLLOW(&lt;symbol&gt;) = { &lt;set_elements&gt; }

where &lt;symbol&gt; should be replaced by the non-terminal and &lt;set_elements&gt; should be replaced by the comma-separated list of elements of the set ordered in the following manner.

<ul>
<li>If EOF belongs to the set, represent it as $.</li>
<li>If EOF belongs to the set, it should be listed before any other element of the set.</li>
<li>All other elements of the set should be listed in the order in which they appear in the grammar.</li>
</ul>
<strong>Example:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>Given the input grammar:

decl -&gt; idList colon ID * idList -&gt; ID idList1 *

idList1 -&gt; *

idList1 -&gt; COMMA ID idList1 * #

the expected output for task 3 is:

FOLLOW(decl) = { $ }

FOLLOW(idList) = { colon }

FOLLOW(idList1) = { colon }

<h2>5.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task 5: Left Factoring</h2>
For this task, your program takes as input a grammar <em>G </em>and outputs a new grammar <em>G<sup>0 </sup></em>that is obtained by left-factoring <em>G</em>. Below, I give a motivation for left factoring, then I present an algorithm for left factoring which is followed by a step by step example and finally, I specify the output format for this task.

<h3>5.5.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left factoring introduction</h3>
The simple expression grammar that we have seen in class does not technically have a predictive parser. For instance the FIRST sets of T + E and T, which are the right-hand sides of the rules for E, are not disjoint.

To write the parser, we looked at the common part (prefix) of the two right hand sides, the T, and started with parse_T().

Then, we either stopped or we continued parsing + E. What we have done is essentially left factoring. We have two rules

E -&gt; T + E

E -&gt; T

and we treated them as E followed by +E or :

E -&gt; T ( + E | epsilon )

By <em>factoring </em>the E out, we have implicitly transformed our input grammar into an equivalent grammar that has a predictive parser. In general, the transformation can be done explicitly and the explicit transformation is called <em>left factoring</em>. For the example above, the resulting grammar would be:

E -&gt; T E1

E1 -&gt; + E | epsilon

In general, we can do left factoring whenever two rules for <u>the same non-terminal </u>have right-hand sides with a common non-trivial (non-empty) prefix. The general algorithm for left factoring is given in the next subsection.

It is important to note that, in general, left-factoring by itself is not sufficient to obtain a grammar that has a predictive recursive descent parser but we need to do left factoring if we hope of obtain an equivalent grammar that might have a predictive recursive descent parser.

<h3>5.5.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left factoring algorithm</h3>
I give the general algorithm for left factoring on the next page, followed by a detailed example. Make an effort to read the algorithm carefully at least twice, once before going through the example and one after going through the example.

In the algorithm, we chose <em>Œ± </em>to be the longest common prefix of two or more rules for <em>A</em>. If there is more than one common prefix that is longest, then, to ensure a unique output of the algorithm, we start with the longest prefix that is first in dictionary order (also, see the discussion below about the output).

<strong>Implementation note 1</strong>: The algorithm modifies the set of rules <em>R </em>while processing them. If you are implementing the set of rules as a vector that you iterate over, you should not delete items from the vector while you are iterating over it. This will lead to undefined behavior. You should keep that in mind in your implementation.

<strong>Implementation note 2</strong>: The algorithm takes as input one grammar <em>G </em>and outputs another grammar <em>G<sup>0</sup></em>. Your implementation does not need to explicitly produce a full grammar description as output, just the rules of the resulting grammar in an order specified later in the text.

<strong>Implementation note 3</strong>: The algorithm assume that the grammar is provided as separate rules. In your implementation, you should treat a rule like A -&gt; B C | B D as two rules.

<strong>Implementation note 4</strong>: The algorithms require the output to be sorted in a specified order. To that end, it assumes that strings are compared using C++ comparison. In C++, ‚ÄúABC‚Äù is smaller than ‚Äúabc‚Äù when compared.

<h3>5.5.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left Factoring Example</h3>
In the following example, the rules are numbered so that I can refer to them in the text. At the start of the algorithm, <em>G<sup>0 </sup></em>is empty and <em>G </em>contains all the rules.

<strong>Algorithm 1: </strong>Algorithm for left factoring

<ul>
<li><strong>Input</strong>: Grammar <em>G </em>= (<em>S,R,T,NT</em>)</li>
<li><strong>Output</strong>: Grammar <em>G<sup>0 </sup></em>= (<em>S<sup>0</sup>,R<sup>0</sup>,T<sup>0</sup>,NT<sup>0</sup></em>)</li>
</ul>
<strong>3</strong>

<ul>
<li><strong>Initialization</strong>:</li>
<li><em>S<sup>0 </sup></em>= <em>S</em>;</li>
<li><em>R<sup>0 </sup></em>= <em>{}</em>; <strong>7 </strong><em>T<sup>0 </sup></em>= <em>T </em>;</li>
</ul>
<h3>8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>NT<sup>0 </sup></em>= <em>{}</em>;</h3>
<strong>9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong><em>G<sup>0 </sup></em>= (<em>S<sup>0</sup>,R<sup>0</sup>,T<sup>0</sup>,NT<sup>0</sup></em>)

<strong>10</strong>

<h3>11 repeat</h3>
<h4>12</h4>
<ul>
<li><strong>if </strong><em>A has two different rules with a non-empty common prefix x: A ‚Üí xy and A ‚Üí xy<sup>0 </sup></em><strong>then</strong></li>
<li>Let <em>Œ± </em>be the longest common prefix for any two right-hand sides of rules of A (see tie breaking in text) <strong>15 </strong>We can divide the rules of <em>A </em>into two groups:</li>
</ul>
<h4>16</h4>
<ul>
<li><em>A ‚Üí Œ±Œ≤</em><sub>1 </sub><em>A ‚Üí Œ≥</em><sub>1</sub></li>
<li><em>A ‚Üí Œ±Œ≤</em><sub>2 </sub><em>A ‚Üí Œ≥</em><sub>2</sub></li>
<li><em>‚Ä¶ ‚Ä¶</em></li>
<li><em>A ‚Üí Œ±Œ≤<sub>k </sub>A ‚Üí Œ≥<sub>m</sub></em></li>
</ul>
<strong>21</strong>

<strong>22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>where none of the right-hand sides <em>Œ≥</em><sub>1</sub><em>,Œ≥</em><sub>2</sub><em>,‚Ä¶,Œ≥<sub>m </sub></em>have <em>Œ± </em>as a prefix.

<strong>23</strong>

// Remove rules with prefix <em>Œ± </em>and add new rules to replace the removed rules

<h3>24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for <em>i </em>= 1 to <em>k </em>do</h3>
<ul>
<li>remove the rules <em>A ‚Üí Œ±Œ≤<sub>i </sub></em>of <em>A </em>from <em>R</em></li>
<li>add the rule <em>A ‚Üí Œ±A<sub>new </sub></em>to <em>R</em></li>
</ul>
<h3>27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for <em>j </em>= 1 to <em>m </em>do</h3>
<strong>28 </strong>add the rule <em>A<sub>new </sub>‚Üí Œ≤<sub>j </sub></em>to <em>R<sup>0 </sup></em><strong>29 </strong>add <em>A<sub>new </sub></em>to <em>NT<sup>0</sup></em>

<h4>30</h4>
// <em>A </em>has no two rules with a non-empty common prefix

<ul>
<li>remove the rules of <em>A </em>from <em>R </em>and add them to <em>R<sup>0</sup></em></li>
<li>remove <em>A </em>from <em>NT </em>and add it to <em>NT<sup>0</sup></em></li>
</ul>
<h3>33 until <em>NT </em>= <em>‚àÖ</em></h3>
<strong>34 </strong>return <em>G<sup>0</sup></em>

<table width="763">
<tbody>
<tr>
<td width="62">G‚Äô:

G:
</td>
<td width="148">S -&gt; C B C D A B C</td>
<td width="552">// 1</td>
</tr>
<tr>
<td width="62"></td>
<td width="148">A -&gt; C B C D</td>
<td width="552">// 2</td>
</tr>
<tr>
<td width="62"></td>
<td width="148">A -&gt; C B C B</td>
<td width="552">// 3</td>
</tr>
<tr>
<td width="62"></td>
<td width="148">A -&gt; C B D</td>
<td width="552">// 4</td>
</tr>
<tr>
<td width="62"></td>
<td width="148">A -&gt; C B B</td>
<td width="552">// 5</td>
</tr>
<tr>
<td width="62"></td>
<td width="148">B -&gt; b</td>
<td width="552">// 6</td>
</tr>
<tr>
<td width="62"></td>
<td width="148">C -&gt; c</td>
<td width="552">// 7</td>
</tr>
<tr>
<td width="62"></td>
<td width="148">D -&gt; d</td>
<td width="552">// 8</td>
</tr>
</tbody>
</table>
First, say we pick non-terminal <em>S</em>. Non-terminal <em>S </em>does not have two or more rules with a common non-empty prefix, so we add all rules of <em>S </em>to <em>G<sup>0 </sup></em>and we get:

<table width="763">
<tbody>
<tr>
<td width="196">G‚Äô: S -&gt; C B C D A B C

G:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A -&gt; C B C D
</td>
<td width="567">// 2</td>
</tr>
<tr>
<td width="196">A -&gt; C B C B</td>
<td width="567">// 3</td>
</tr>
<tr>
<td width="196">A -&gt; C B D</td>
<td width="567">// 4</td>
</tr>
<tr>
<td width="196">A -&gt; C B B</td>
<td width="567">// 5</td>
</tr>
<tr>
<td width="196">B -&gt; b</td>
<td width="567">// 6</td>
</tr>
<tr>
<td width="196">C -&gt; c</td>
<td width="567">// 7</td>
</tr>
<tr>
<td width="196">D -&gt; d</td>
<td width="567">// 8</td>
</tr>
</tbody>
</table>
Next, we pick non-terminal <em>A</em>. We identify rules 2 and 3 as the two rules with the longest common prefix, which is <em>C B C</em>. So, we get the following.

<table width="763">
<tbody>
<tr>
<td width="206">G‚Äô: S -&gt; C B C D A B C

A1 -&gt; D

A1 -&gt; B

G:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A -&gt; C B C A1
</td>
<td width="557">// 2</td>
</tr>
<tr>
<td width="206">A -&gt; C B D</td>
<td width="557">// 4</td>
</tr>
<tr>
<td width="206">A -&gt; C B B</td>
<td width="557">// 5</td>
</tr>
<tr>
<td width="206">B -&gt; b</td>
<td width="557">// 6</td>
</tr>
<tr>
<td width="206">C -&gt; c</td>
<td width="557">// 7</td>
</tr>
<tr>
<td width="206">D -&gt; d</td>
<td width="557">// 8</td>
</tr>
</tbody>
</table>
Note, how the rules for <em>A</em>1 are added to <em>G<sup>0</sup></em>, but the rules for <em>A </em>are not added to <em>G<sup>0 </sup></em>because they might still have common prefixes with other rules. In the new grammar <em>G</em>, the longest prefix is <em>C B </em>which appears in grammar rules 2 , 4 and 5. After the second pass, we obtain:

<table width="763">
<tbody>
<tr>
<td width="62">G‚Äô:</td>
<td width="151">S -&gt; C B C D A B C

A1 -&gt; D

A1 -&gt; B

A2 -&gt; C A1

A2 -&gt; D

A2 -&gt; B
</td>
<td width="550"></td>
</tr>
<tr>
<td width="62">G:</td>
<td width="151">A -&gt; C B A2</td>
<td width="550">// 2</td>
</tr>
<tr>
<td width="62"></td>
<td width="151">B -&gt; b</td>
<td width="550">// 6</td>
</tr>
<tr>
<td width="62"></td>
<td width="151">C -&gt; c</td>
<td width="550">// 7</td>
</tr>
<tr>
<td width="62"></td>
<td width="151">D -&gt; d</td>
<td width="550">// 8</td>
</tr>
</tbody>
</table>
From this point forward, there will be no two rules for a non-terminal that share a non-empty prefix, so we will end up adding all the remaining rules, one by one, to <em>G<sup>0 </sup></em>until <em>G </em>is empty. The final grammar that we obtain is:

<table width="763">
<tbody>
<tr>
<td width="62">G‚Äô:</td>
<td width="701">A1 -&gt; D

A1 -&gt; B

A2 -&gt; B

A2 -&gt; C A1

A2 -&gt; D

S -&gt; C B C D A B C

A -&gt; C B A2
</td>
</tr>
</tbody>
</table>
<ul>
<li>-&gt; b</li>
<li>-&gt; c</li>
<li>-&gt; d</li>
</ul>
This grammar is not sorted, but the actual output of Task 5 should be sorted as explained below.

<h4>5.5.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task 5 requirements</h4>
The algorithm for left factoring as described above is relatively straightforward, but we need to specify the exact format of the output so that the output of your program is uniquely determined by the specified format. There are three sources of possible variation in the output format when the algorithm is followed:

<ol>
<li>The order in which the rules are listed</li>
<li>The names given to the new non-terminals that are introduced by the algorithm.</li>
<li>If multiple prefixes are longest common prefixes shared by two or more rules, then which one we chose first affects the result because it affects which rules a newly introduced name goes with.</li>
</ol>
The following output format uniquely defines the expected output:

<ol>
<li>The grammar rules should be printed in lexicographic order (dictionary order) by treating the left-hand side followed by the right-hand side as one sequence. According to this order if we have the two rules A -&gt; AB C and A -&gt; A Z, then A -&gt; A Z is listed first. The lexicographic comparison is done one lexeme at a time. More details are given in the implementation guide.</li>
<li>If multiple rules for <em>X </em>are left factored for the first time, then the new introduced name is <em>X</em>1</li>
<li>If multiple rules for <em>X </em>are left factored and we have already introduced names <em>X</em>1, <em>X</em>2, ‚Ä¶., <em>Xk</em>, then the new name should be <em>Xk </em>+ 1. Of course, for this to work, we should assume that these newly introduced names are not already used in the grammar. We will make this assumption and it will be satisfied by all test cases.</li>
<li>If in a given iteration, more than one common prefix is longest prefix shared by two or more rules, we chose the longest common prefix that appears first in dictionary order (this situation did not occur in the example above).</li>
</ol>
The example above already followed the naming convention specified here, so the naming requirement is satisfied. So, we have to sort the grammar lexicographically to obtain a grammar that satisfy the output format requirements. If we do so, we obtain the grammar that should be printed. Note that we only need to print the rules of the resulting grammar. That is why the name <em>G<sup>0 </sup></em>is omitted from the output. Also, the output format (see below) requires that every rule be terminated with the # symbol.

<ul>
<li>-&gt; C B A2 #</li>
</ul>
A1 -&gt; B #

A1 -&gt; D #

A2 -&gt; B #

A2 -&gt; C A1 #

A2 -&gt; D #

<ul>
<li>-&gt; b #</li>
<li>-&gt; c #</li>
<li>-&gt; d #</li>
</ul>
S -&gt; C B C D A B C #

To summarize, the following is what you should do for Task 5:

<ol>
<li>Apply the left factoring algorithm to obtain <em>G<sup>0</sup></em>. Make sure to follow the naming convention when new non-terminals are introduced.</li>
<li>Sort the resulting grammar lexicographically.</li>
<li>Print the rules of the resulting grammar by first printing the left-hand side, followed by space, followed by -&gt;, followed by space, then followed by the symbols on the right-hand side of the rule separated by space(s) and finally followed by #. If there are no symbols on the right-hand side of a particular rule of the resulting sorted grammar, then you simply print the # after the -&gt;.</li>
</ol>
<h2>5.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task 6: Eliminating Left Recursion</h2>
For this task, your program reads the grammar, which is assumed to have no epsilon rules and to be cycle-free, and prints the resulting grammar after eliminating left recursion as explained below.

<h3>5.6.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Introduction to eliminating left recursion</h3>
We say that a rule has immediate left recursion if it is of the form <em>A ‚Üí AŒ± </em>for some <em>Œ±</em>. It is called <em>left recursion </em>because the <em>A </em>appears on the left-hand side of the rule and also appears as the leftmost symbol of the right-hand side of the rule. If this is the only rule for <em>A </em>and we try to write a recursive descent parser, we end up with the following which will create an infinite loop.

<table width="763">
<tbody>
<tr>
<td width="763">parse_A()

{

parse_A()

// parse alpha }
</td>
</tr>
</tbody>
</table>
It is clear that if a grammar has rules with left recursion, the grammar cannot have a predictive parser. Left recursion is not restricted to immediate left recursion where the same non-terminal appears on the left side of a rule and as the leftmost symbol of the left-hand side of the rule. Left recursion can be indirect as in the following example:

<table width="763">
<tbody>
<tr>
<td width="51"><em>A</em></td>
<td width="712"><em>‚Üí B a | b</em></td>
</tr>
<tr>
<td width="51"><em>B</em></td>
<td width="712"><em>‚Üí Ab | a</em></td>
</tr>
</tbody>
</table>
Here, the grammar is left-recursive because <em>A ‚áí B a ‚áí Aba</em>. Also, <em>B ‚áí Ab ‚áí B ab</em>. Also, we don‚Äôt have a predictive parser because <em>FIRST</em>(<em>B a</em>) <em>‚à© FIRST</em>(<em>b</em>) <em>6</em>= <em>‚àÖ</em>. Also, <em>FIRST</em>(<em>Ab</em>) <em>‚à© FIRST</em>(<em>a</em>) <em>6</em>= <em>‚àÖ</em>.

In general, we say that a grammar is <em>left-recursive </em>if it has a non-terminal <em>A </em>such that <em>A ‚áí</em><sup>+ </sup><em>AŒ± </em>for some string <em>Œ± </em>of terminals and non-terminals (the + above the arrow stands for one or more as opposed to the Kleene star which stands for zero or more). If a grammar is left-recursive, not only it cannot have a predictive top-down parser, but it cannot be handled by a top-down parser! So, if we want to handle a grammar with left recursion in a top-down fashion, we need to transform it to another equivalent grammar that does not have left recursion.

Before giving the general algorithm, we consider the case of immediate left recursion. If <em>A </em>has immediate left recursion, then the rules for <em>A </em>can be divided into two groups:

<table width="763">
<tbody>
<tr>
<td width="51"><em>A</em></td>
<td width="712"><em>‚Üí AŒ±</em><sub>1 </sub><em>| AŒ±</em><sub>2 </sub><em>| ‚Ä¶ | AŒ±<sub>k</sub></em></td>
</tr>
<tr>
<td width="51"><em>A</em></td>
<td width="712"><em>‚Üí Œ≤</em><sub>1 </sub><em>| Œ≤</em><sub>2 </sub><em>| ‚Ä¶ | Œ≤<sub>m</sub></em></td>
</tr>
</tbody>
</table>
where none-of the <em>Œ≤<sub>j</sub></em>, <em>j </em>= 1<em>,‚Ä¶,m</em>, starts with <em>A</em>. We can rewrite the grammar into the following equivalent grammar.

<em>A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‚Üí Œ≤</em><sub>1 </sub><em>A</em>1 <em>| Œ≤</em><sub>2 </sub><em>A</em>1 <em>| ‚Ä¶ | Œ≤<sub>m </sub>A</em>1

<em>A</em>1 <em>‚Üí Œ±</em><sub>1 </sub><em>A</em>1 <em>| Œ±</em><sub>2 </sub><em>A</em>1 <em>| ‚Ä¶ | Œ±<sub>k </sub>A</em>1 <em>| </em>

Note that this transformation would work even if all the right-hand sides of the rules of <em>A </em>start with <em>A</em>, in which case <em>A </em>is useless. The transformation works in that case because there are no <em>Œ≤<sub>i</sub></em>, so the resulting grammar will have no <em>A </em>rules (rules with <em>A </em>on the left-hand side) and all the resulting rules will be <em>A</em>1 rules and <em>A</em>1 would also end up being a useless symbol. In the algorithm, we don‚Äôt concern ourselves with whether or not there are useless symbols in the grammar.

So far, we explained how to eliminate left recursion when we have immediate left recursion (see above). The transformation does not handle the case where we have indirect left recursion. Next we present the general algorithm for eliminating left recursion (direct or indirect).

<h3>5.6.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Algorithm for eliminating left recursion</h3>
The algorithm that I will give here for eliminating left recursion assumes that the grammar has no -rules (rules whose right-hand side is ) and that the grammar has no cyclical derivations, i.e. derivations of the form <em>A ‚áí</em><sup>+ </sup><em>A </em>(remember that + means one or more). If a grammar has cyclical derivations, we say that the grammar has cycles. For this task, you can assume in your solution that the grammar has no cycles and no -rules and you don‚Äôt have to check for that in your solution. I give the general algorithm for eliminating left recursion, followed by a detailed example. Make sure to read the algorithm carefully at least twice, once before reading the example and once after reading the example.

The algorithm starts by initializing the grammar of <em>G<sup>0 </sup></em>(lines 4‚Äì9). The set of non-terminal <em>NT<sup>0 </sup></em>is initialized to be equal to the set of non-terminals of the given grammar sorted in dictionary order (line 8). For reference in the remainder of the algorithm, the elements of the set <em>NT<sup>0 </sup></em>are called <em>A</em><sub>1</sub><em>,‚Ä¶,A<sub>n</sub></em>. Then, the algorithm creates a set of <em>Rules </em>for each non-terminal (line 11‚Äì15). This step groups all the rules for each non-terminal together in a set. Next, each non-terminal <em>A<sub>i </sub></em>is considered in sorted order

(line 17) and the algorithm iterates over all non-terminals that appear before <em>A<sub>i </sub></em>in the sorted order (line 18). If any rule <em>r </em>for <em>A<sub>i</sub></em>

(line 20) has a right-hand side of the form <em>A<sub>j </sub>Œ≥ </em>(line 18), where <em>A<sub>j </sub></em>appears before <em>A<sub>i </sub></em>in the order (note that <em>j &lt; i </em>in line 18), the rule is an <em>offending </em>rule (in general, an offending rule is a rule of the form <em>A ‚Üí B Œ≥ </em>such that <em>B </em>appears before <em>A </em>in the sorted order of non-terminals). We get rid of the offending rule by rewriting the rules for <em>A<sub>i</sub></em>. For every offending rule <em>r </em>of <em>A<sub>i </sub></em>of the form <em>A<sub>i </sub>‚Üí A<sub>j </sub>Œ≥ </em>(line 18), we remove rule <em>r </em>from <em>Rules</em>[<em>A<sub>i</sub></em>] (line 21) and we add new rules to <em>Rules</em>[<em>A<sub>i</sub></em>]. The new rules are obtained by replacing <em>A<sub>j </sub></em>in the offending rule with all possible values of <em>A<sub>j </sub></em>with the right-hand sides of rules for <em>A<sub>j </sub></em>(line 22‚Äì24).

This last step might be confusing, so I explain it with an example. Assume we have an offending rule <em>A ‚Üí B Œ≥</em>, where <em>B </em>appears before <em>A </em>in the order of non-terminals. Let <em>B ‚Üí Œ¥</em><sub>1 </sub><em>| Œ¥</em><sub>2 </sub><em>| ‚Ä¶ | Œ¥<sub>k </sub></em>be the current rules for <em>B </em>(which might be different from the original rules of <em>B </em>in the grammar because <em>B </em>was considered before <em>A </em>and its rules might have been rewritten). We remove <em>A ‚Üí B Œ≥ </em>from the rules of <em>A </em>and we add the rules <em>B ‚Üí Œ¥</em><sub>1 </sub><em>Œ≥ | Œ¥</em><sub>2 </sub><em>Œ≥ | ‚Ä¶ | Œ¥<sub>k </sub>Œ≥ </em>in its place.

After rewriting the rules for <em>A<sub>i</sub></em>, we consider the resulting rules for <em>A<sub>i </sub></em>and eliminate any direct left recursion from them as described earlier. No pseudocode is provided for that.

The resulting grammar <em>G<sup>0 </sup></em>has the same starting symbol and the same set of terminals as <em>G</em>. The non-terminals of <em>G<sup>0 </sup></em>are all the original non-terminals plus all the newly added non-terminals when direct left recursion is eliminated. The rules of <em>G<sup>0 </sup></em>is the union of all the rules of the non-terminals of <em>G<sup>0</sup></em>.

<h3>5.6.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Eliminating Left Recursion Example</h3>
Consider the grammar

<table width="763">
<tbody>
<tr>
<td width="62">G:</td>
<td width="701">S -&gt; D B C D A B C

A&nbsp;&nbsp; -&gt; D B C D

B&nbsp;&nbsp; -&gt; A B C B

C&nbsp;&nbsp;&nbsp; -&gt; B D

A&nbsp;&nbsp; -&gt; C B B

B&nbsp;&nbsp; -&gt; b

C&nbsp;&nbsp;&nbsp; -&gt; c

D&nbsp;&nbsp; -&gt; d
</td>
</tr>
</tbody>
</table>
<strong>Algorithm 2: </strong>Algorithm Eliminating Left Recursion

<ul>
<li><strong>Input: </strong>Grammar <em>G </em>= (<em>S,R,T,NT</em>) with no -rules and no cycles</li>
<li><strong>Output: </strong>Grammar <em>G<sup>0 </sup></em>= (<em>S<sup>0</sup>,R<sup>0</sup>,T<sup>0</sup>,NT<sup>0</sup></em>) with the same language as <em>G </em>but with no left recursion</li>
</ul>
<strong>3</strong>

<ul>
<li><strong>Initialization:</strong></li>
<li><em>S<sup>0 </sup></em>= <em>S</em></li>
</ul>
<h3>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>R<sup>0 </sup></em>= <em>{}</em></h3>
<ul>
<li><em>T<sup>0 </sup></em>= <em>T</em></li>
<li><em>NT<sup>0 </sup></em>= <em>NT </em>sorted lexicographically (dictionary order). Say <em>NT<sup>0 </sup></em>= <em>{A</em><sub>1</sub><em>,A</em><sub>2</sub><em>,‚Ä¶,A<sub>n</sub>} </em><strong>9 </strong><em>G<sup>0 </sup></em>= (<em>S<sup>0</sup>,R<sup>0</sup>,T<sup>0</sup>,NT<sup>0</sup></em>)</li>
</ul>
<h4>10</h4>
<ul>
<li><strong>forall </strong><em>non-terminal A ‚àà NT </em><strong>do</strong></li>
<li><em>Rules</em>[<em>A</em>] = <em>{}</em></li>
</ul>
<h4>13</h4>
First, we sort the non-terminals and we group the rules for each non-terminal together. We get the following grammar.

Rules[A] = { A -&gt; D B C D , A -&gt; C B B }

Rules[B] = { B -&gt; A B C B , B -&gt; b }

Rules[C] = { C -&gt; B D , C -&gt; c }

Rules[D] = { D -&gt; d }

Rules[S] = { S -&gt; D B C D A B C }

Now, we consider the non-terminals one by one in the sorted order. We start with <em>A</em>. <em>A </em>has no offending rules, so we don‚Äôt need to rewrite any of the rules of <em>A</em>. Also, <em>A </em>does not have any direct left recursion, so we are done with <em>A </em>without having changed any rules. The resulting rules are the same as the original rules. I highlight the right-hand sides of the rules of <em>A </em>in red because that will be used in explaining how the rules of <em>B </em>are rewritten.

<table width="763">
<tbody>
<tr>
<td width="313">Rules[A] = A -&gt; D B C D , A -&gt; C B B Rules[B] = B -&gt; A B C B , B -&gt; b</td>
<td width="450">// done</td>
</tr>
</tbody>
</table>
Rules[C] = C -&gt; B D , C -&gt; c

Rules[D] = D -&gt; d

Rules[S] = S -&gt; D B C D A B C

Next, we consider <em>B</em>. <em>B </em>has one offending rule which is <em>B ‚Üí </em><em>A B C B</em>. This rule is offending because <em>A </em>appears before <em>B </em>in the sorted list of non-terminals. We replace the offending rule for <em>B </em>with the rules <em>B ‚Üí </em><em>D B C D B C B </em>and <em>B ‚Üí </em><em>C B B B C B </em>which are obtained by replacing <em>A </em>with all possible right-hand sides of rules of <em>A</em>. After the replacement, the resulting rules for <em>B </em>have no direct left recursion. We obtain the following grammar

<table width="763">
<tbody>
<tr>
<td width="445">Rules[A] = A -&gt; D B C D , A -&gt; C B B</td>
<td width="318">// done</td>
</tr>
<tr>
<td width="445">Rules[B] = B -&gt; D B C D B C B , B -&gt; C B B B C B, B -&gt; b

Rules[C] = C -&gt; B D , C -&gt; c

Rules[D] = D -&gt; d

Rules[S] = S -&gt; D B C D A B C
</td>
<td width="318">// done</td>
</tr>
</tbody>
</table>
Now, we consider the rules for <em>C</em>. <em>C </em>has one offending rule <em>C ‚Üí B D</em>. We eliminate the offending rule by replacing <em>B </em>with the <em>current </em>right-hand sides of rules for <em>B </em>and we obtain the following

Rules[A] = { A -&gt; D B C D , A -&gt; C B B }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // done

Rules[B] = { B -&gt; D B C D B C B , B -&gt; C B B B C B, B -&gt; b }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // done Rules[C] = { C -&gt; D B C D B C B D , C -&gt; C B B B C B D , C -&gt; b D , C -&gt; c }

Rules[D] = { D -&gt; d }

Rules[S] = { S -&gt; D B C D A B C }

The resulting rules for <em>C </em>now have direct left recursion, so we need to eliminate it as required in line 15 of the algorithm. We follow the approach presented in Section 5.5.1. The rules for <em>C </em>can be divided into two parts

<table width="763">
<tbody>
<tr>
<td width="213">C -&gt; C B B B C B D.</td>
<td width="550">// direct left recursion</td>
</tr>
<tr>
<td width="213">C -&gt; D B C D B C B D</td>
<td width="550">// no direct left recursion</td>
</tr>
<tr>
<td width="213">C -&gt; b D</td>
<td width="550">// no direct left recursion</td>
</tr>
<tr>
<td width="213">C -&gt; c</td>
<td width="550">// no direct left recursion</td>
</tr>
</tbody>
</table>
We rewrite these rules as we explained in Section 5.5.1 by introducing a new non-terminal <em>C</em>1 and the rules become

C -&gt; D B C D B C B D C1

C -&gt; b D C1

C -&gt; c C1

C1 -&gt; B B B C B D C1

C1 -&gt;

The resulting grammar is now

<table width="763">
<tbody>
<tr>
<td width="520">Rules[A] = { A -&gt; D B C D , A -&gt; C B B }</td>
<td width="243">// done</td>
</tr>
<tr>
<td width="520">Rules[B] = { B -&gt; D B C D B C B , B -&gt; C B B B C B, B -&gt; b }</td>
<td width="243">// done</td>
</tr>
<tr>
<td width="520">Rules[C] = { C -&gt; D B C D B C B D C1 , C -&gt; b D C1 , C -&gt; c C1 }</td>
<td width="243">// done</td>
</tr>
<tr>
<td width="520">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rules[C1] = { C1 -&gt; B B B C B D C1, C1 -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

Rules[D] = { D -&gt; d }

Rules[S] = { S -&gt; D B C D A B C }
</td>
<td width="243">// done</td>
</tr>
</tbody>
</table>
Next, we consider non-terminal <em>D </em>which has no offending rules and no direct left recursion. We get:

<table width="763">
<tbody>
<tr>
<td width="520">Rules[A] = { A -&gt; D B C D , A -&gt; C B B }</td>
<td width="243">// done</td>
</tr>
<tr>
<td width="520">Rules[B] = { B -&gt; D B C D B C B , B -&gt; C B B B C B, B -&gt; b }</td>
<td width="243">// done</td>
</tr>
<tr>
<td width="520">Rules[C] = { C -&gt; D B C D B C B D C1 , C -&gt; b D C1 , C -&gt; c C1 }</td>
<td width="243">// done</td>
</tr>
<tr>
<td width="520">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rules[C1] = { C1 -&gt; B B B C B D C1, C1 -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</td>
<td width="243">// done</td>
</tr>
<tr>
<td width="520">Rules[D] = { D -&gt; d }

Rules[S] = { S -&gt; D B C D A B C }
</td>
<td width="243">// done</td>
</tr>
</tbody>
</table>
Finally, we consider non-terminal <em>S </em>which has one offending rule, so we rewrite it by replacing <em>D </em>with all possible right-hand sides of the rules for <em>D </em>(which is one rule only) and we get

<table width="763">
<tbody>
<tr>
<td width="520">Rules[A] = { A -&gt; D B C D , A -&gt; C B B }</td>
<td width="243">// done</td>
</tr>
<tr>
<td width="520">Rules[B] = { B -&gt; D B C D B C B , B -&gt; C B B B C B, B -&gt; b }</td>
<td width="243">// done</td>
</tr>
<tr>
<td width="520">Rules[C] = { C -&gt; D B C D B C B D C1 , C -&gt; b D C1 , C -&gt; c C1 }</td>
<td width="243">// done</td>
</tr>
<tr>
<td width="520">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rules[C1] = { C1 -&gt; B B B C B D C1, C1 -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</td>
<td width="243">// done</td>
</tr>
<tr>
<td width="520">Rules[D] = { D -&gt; d }</td>
<td width="243">// done</td>
</tr>
<tr>
<td width="520">Rules[S] = { S -&gt; d B C D A B C }</td>
<td width="243">// done</td>
</tr>
</tbody>
</table>
This is the end of the example. Next we state the requirements for Task 6.

<h4>5.6.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Task 6 requirements</h4>
As we have discussed for left factoring, we need to ensure that the output of the algorithm for eliminating left recursion is unique. A large part of ensuring uniqueness is already handled by sorting the non-terminals in dictionary order. In order to ensure uniqueness of the final output, we require that the resulting rules be printed in dictionary order as I explained for the left factoring task. Also, when introducing a new name to eliminate direct left recursion for non-terminal <em>X</em>, we call the newly introduced name <em>X</em>1 as is explained in the general case and I did in the example. You can assume that none of the original non-terminal names will be the same as the the newly introduced name.

The example above already followed the naming convention specified here, so the naming requirement is satisfied. To obtain the final output, we have to sort the grammar lexicographically to obtain a grammar that satisfy the output format requirements. If we do so, we obtain the grammar that should be printed. Note that you are only asked to print the rules of the resulting grammar. Also, the output format (see below) requires that every rule be terminated with the # symbol. The final output for the example above will be the following.

A -&gt; C B B #

<ul>
<li>-&gt; D B C D #</li>
<li>-&gt; C B B B C B #</li>
</ul>
B -&gt; D B C D B C B #

<ul>
<li>-&gt; b #</li>
<li>-&gt; b D C1 #</li>
</ul>
C -&gt; c C1 #

<ul>
<li>-&gt; D B C D B C B D C1 #</li>
</ul>
C1 -&gt; #

C1 -&gt; B B B C B D C1 #

<ul>
<li>-&gt; d #</li>
</ul>
S -&gt; d B C D A B C #

To summarize, the following is what you should do for Task 5:

<ol>
<li>Apply the elimination of left recursion algorithm to obtain a new grammar whose rules don‚Äôt have direct or indirect left recursion.</li>
<li>Sort the resulting grammar lexicographically.</li>
<li>Print the rules of the resulting grammar by first printing the left-hand side, followed by space, followed by -&gt;, followed by space, the followed by the symbols on the right-hand side separated by space and finally followed by #. If there are no symbols on the right-hand side of a particular rule of the resulting sorted grammar, then you simply print the # after the -&gt;.</li>
</ol>
<h1>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Implementation</h1>
<h2>6.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lexer</h2>
A lexer that can recognize ID, ARROW, STAR, OR and HASH tokens is provided for this project. You are required to use it and you should not modify it.

<h2>6.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Reading command-line argument</h2>
As mentioned in the introduction, your program must read the grammar from stdin (standard input) and the task number from command line arguments. The following piece of code shows how to read the first command line argument and perform a task based on the value of that argument. Use this code as a starting point for your main function.

// NOTE: You should get the full version of this code in the // provided code. Do not copy/paste from this document.

#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;

int main (int argc, char* argv[])

{ int task;

if (argc &lt; 2) {

printf(‚ÄúError: missing argument\n‚Äù); return 1;

}

task = atoi(argv[1]);

switch (task) { case 1:

// TODO: perform task 1. break; // ‚Ä¶

default: printf(‚ÄúError: unrecognized task number %d\n‚Äù, task); break;

} return 0;

}

<h2>6.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Testing</h2>
You are provided with a script to run your program on all tasks for each of the test cases. The test cases that we provided for this project are not extensive. <strong>They are meant to serve as example cases and are not meant to test all functionality</strong>.

The test cases on the submission site will be extensive. <strong>You are expected to develop your own additional test cases based on the project specification</strong>.

To run your program for this project, you need to specify the task number through command line arguments. For example, to run task 3:

$ ./a.out 3

Your program should read the input grammar from standard input. To read the input grammar from a text file, you can redirect standard input:

$ ./a.out 3 &lt; test.txt

For this project we use 5 expected files per each test case input. For an input file named test.txt , the expected files are test.txt.expected1, test.txt.expected2, test.txt.expected3, test.txt.expected4 and test.txt.expected5 corresponding to tasks 1 through 5. The test script test_p2.sh , provided with the project material, takes one command line argument indicating the task number to use. So for example to test your program against all test cases for task 2, use the following command:

$ ./test_p2.sh 2

To test your program against all test cases for all tasks, you need to run the test script 6 times (you can also write a script to do that):

$ ./test_p2.sh 1 $ ./test_p2.sh 2 $ ./test_p2.sh 3 $ ./test_p2.sh 4 $ ./test_p2.sh 5

$ ./test_p2.sh 5

<h1>7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Evaluation</h1>
Your submission will be graded on passing the test cases on Gradescope. The test cases (there will be multiple test cases in each category, each with equal weight) will be broken down in the following way (out of 100 points):

<ul>
<li>Parsing: No points if correct. If not correct, there will be a 15% deduction from the grade.</li>
<li>Task 1: 10 points</li>
<li>Task 2: 10 points</li>
<li>Task 3: 20 points</li>
<li>Task 4: 20 points</li>
<li>Task 5: 20 points</li>
<li>Task 6: 20 points</li>
</ul>
The points are not assigned based on the difficulty. Tasks 5 and 6 are more involved than tasks 3 and 4 but are assigned the same points. As mentioned above, if your program does not correctly parse its input, there will be a 15% deduction from the grade.

<h1>8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Submission</h1>
Submit your individual code files on GradeScope. <strong>Do not submit .zip files</strong>.

The gradescope submission will be tested on a separate category for syntax checking. There are no provided test cases for that category.

<strong>Important Note</strong>. For this project, there is a timeout that we enforce when testing submissions. Programs that are functionally correct but that take an inordinate amount of time can be timed out before finishing execution. This is typically not an issue because the timeout period is generous, but if <strong>your implementation is very inefficient, it risks being timed out and you will not get credit for test cases for which the program is timed out</strong>.
